{"file_contents":{"index.js":{"content":"const { Client, GatewayIntentBits, Collection } = require('discord.js');\nconst { joinVoiceChannel, createAudioPlayer, createAudioResource, AudioPlayerStatus, VoiceConnectionStatus } = require('@discordjs/voice');\nconst play = require('play-dl');\nconst fs = require('fs');\nconst path = require('path');\nconst config = require('./settings/config');\nrequire('dotenv').config();\n\nconst client = new Client({\n    intents: [\n        GatewayIntentBits.Guilds,\n        GatewayIntentBits.GuildVoiceStates,\n        GatewayIntentBits.GuildMessages,\n        GatewayIntentBits.MessageContent\n    ]\n});\n\nclient.commands = new Collection();\nclient.config = config;\nclient.queues = new Map();\nclient.inactivityTimers = new Map();\n\nconst commandsPath = path.join(__dirname, 'commands');\nconst commandFiles = fs.readdirSync(commandsPath).filter(file => file.endsWith('.js'));\n\nfor (const file of commandFiles) {\n    const filePath = path.join(commandsPath, file);\n    const command = require(filePath);\n    client.commands.set(command.name, command);\n    console.log(`‚úÖ Loaded command: ${command.name}`);\n}\n\nclient.once('ready', () => {\n    console.log(`ü§ñ Bot is online as ${client.user.tag}`);\n    client.user.setActivity('!play for music', { type: 3 });\n});\n\nclient.on('messageCreate', async message => {\n    if (message.author.bot) return;\n    if (!message.content.startsWith(config.prefix)) return;\n\n    const args = message.content.slice(config.prefix.length).trim().split(/ +/);\n    const commandName = args.shift().toLowerCase();\n\n    const command = client.commands.get(commandName) || \n                   client.commands.find(cmd => cmd.aliases && cmd.aliases.includes(commandName));\n\n    if (!command) return;\n\n    try {\n        await command.execute(message, args, client);\n    } catch (error) {\n        console.error(`Error executing command ${commandName}:`, error);\n        message.reply('‚ùå There was an error!');\n    }\n});\n\nclient.login(process.env.DISCORD_TOKEN);\n","size_bytes":1969},"replit.md":{"content":"# Discord Music Bot\n\n## Overview\n\nThis is a Discord music bot built with Discord.js v14 and discord-player v7. The bot enables users to play music in voice channels through text commands. It supports multiple music sources through extractors (including Spotify and YouTube) and provides audio playback with queue management. The bot uses a prefix-based command system and includes features like auto-disconnect on inactivity.\n\n## Recent Changes\n\n**October 2, 2025**\n- Implemented core bot functionality with !play (!p) command for Spotify and song name playback\n- Added auto-join functionality when users execute play command\n- Implemented proper auto-leave after 2 minutes of playback inactivity (triggers on playerFinish, emptyQueue, emptyChannel events)\n- Set up automatic command loading from commands/* directory\n- Configured environment variables with DISCORD_TOKEN\n- Updated to use @discord-player/extractor with DefaultExtractors via extractors.loadMulti()\n\n## User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n## System Architecture\n\n### Bot Framework\n- **Discord.js v14**: Core bot framework handling Discord API interactions\n- **Gateway Intents**: Configured for Guilds, GuildVoiceStates, GuildMessages, and MessageContent to enable voice and message functionality\n- **Command Pattern**: Commands stored in a Collection and dynamically loaded from `/commands` directory\n- **Command Aliases**: Support for command shortcuts (e.g., 'p' for 'play')\n\n### Music Player Architecture\n- **discord-player v7**: Primary music playback engine\n- **Audio Quality**: Configured for highest quality audio with ytdl options (highestaudio, high watermark buffer)\n- **Extractor System**: Uses `@discord-player/extractor` with DefaultExtractors for multi-source music support\n- **Queue Management**: Per-guild queue system managed through discord-player's useQueue\n\n### Voice Connection Management\n- **@discordjs/voice**: Handles voice channel connections and audio streaming\n- **Audio Processing**: Uses ffmpeg-static for audio encoding/decoding\n- **Encryption**: libsodium-wrappers for voice encryption\n- **Auto-disconnect**: Inactivity timer system that disconnects bot after 2 minutes (120000ms) of no playback\n\n### Command System\n- **Prefix-based**: Uses '!' as default command prefix (configurable)\n- **Dynamic Loading**: Commands automatically loaded from `/commands` directory on startup\n- **File-based Structure**: Each command is a separate module exporting name, aliases, description, and execute function\n- **Message Parsing**: Splits command arguments by spaces for flexible input handling\n\n### Configuration Management\n- **Centralized Config**: `/settings/config.js` stores bot-wide settings\n- **Environment Variables**: `.env` file for sensitive data (Discord token, API keys)\n- **Configuration Options**:\n  - Command prefix\n  - Inactivity timeout duration\n  - Embed color for rich messages\n\n### Audio Features\n- **Volume Control**: Default volume set to 50%\n- **Self-deafening**: Bot automatically deafens itself in voice channels to reduce bandwidth\n- **Queue Metadata**: Tracks requesting user, channel, and guild information\n- **Multi-source Support**: Can play from Spotify, YouTube, and other sources via extractors\n\n## External Dependencies\n\n### Discord Services\n- **Discord Bot API**: Primary integration for bot functionality (requires bot token)\n- **Discord Gateway**: Real-time event system for messages and voice state changes\n- **Discord Voice**: WebSocket-based voice connection for audio streaming\n\n### Music Sources & Extractors\n- **discord-player/extractor**: Abstraction layer for multiple music sources\n- **play-dl**: YouTube and other platform extraction\n- **Spotify API**: Indirect integration through discord-player extractors (may require credentials)\n- **YouTube/SoundCloud**: Supported through DefaultExtractors\n\n### Audio Processing\n- **ffmpeg-static**: Self-contained FFmpeg binary for audio encoding\n- **libsodium**: Cryptographic library for voice packet encryption\n\n### Runtime Dependencies\n- **Node.js**: JavaScript runtime environment\n- **dotenv**: Environment variable management from .env file\n- **file-system (fs)**: Command file loading and directory operations","size_bytes":4231},"commands/play.js":{"content":"const { joinVoiceChannel, createAudioPlayer, createAudioResource, AudioPlayerStatus } = require('@discordjs/voice');\nconst play = require('play-dl');\n\nasync function playNext(guildId, client) {\n    const serverQueue = client.queues.get(guildId);\n    if (!serverQueue || serverQueue.songs.length === 0) {\n        if (client.inactivityTimers.has(guildId)) {\n            clearTimeout(client.inactivityTimers.get(guildId));\n        }\n        const timer = setTimeout(() => {\n            if (serverQueue && serverQueue.connection) {\n                serverQueue.connection.destroy();\n                client.queues.delete(guildId);\n            }\n        }, client.config.inactivityTimeout);\n        client.inactivityTimers.set(guildId, timer);\n        return;\n    }\n\n    const song = serverQueue.songs[0];\n\n    try {\n        const stream = await play.stream(song.url);\n        const resource = createAudioResource(stream.stream, {\n            inputType: stream.type,\n            inlineVolume: true\n        });\n        \n        resource.volume.setVolume(0.7);\n        \n        serverQueue.player.play(resource);\n        serverQueue.textChannel.send(`üéµ Now playing: **${song.title}**`);\n        \n        if (client.inactivityTimers.has(guildId)) {\n            clearTimeout(client.inactivityTimers.get(guildId));\n            client.inactivityTimers.delete(guildId);\n        }\n    } catch (error) {\n        console.error('Playback error:', error);\n        serverQueue.textChannel.send('‚ùå Error playing this song, skipping...');\n        serverQueue.songs.shift();\n        playNext(guildId, client);\n    }\n}\n\nmodule.exports = {\n    name: 'play',\n    aliases: ['p'],\n    description: 'Play a song from Spotify, YouTube, or SoundCloud',\n    async execute(message, args, client) {\n        const voiceChannel = message.member?.voice?.channel;\n        if (!voiceChannel) {\n            return message.reply('‚ùå You need to be in a voice channel!');\n        }\n\n        if (!args.length) {\n            return message.reply('‚ùå Please provide a song name or link!');\n        }\n\n        const query = args.join(' ');\n        const searchMsg = await message.reply(`üîç Searching for best match...`);\n\n        try {\n            let songInfo;\n            \n            if (play.yt_validate(query) === 'video') {\n                songInfo = await play.video_info(query);\n            } else if (play.sp_validate(query)) {\n                const spotifyData = await play.spotify(query);\n                if (spotifyData.type === 'track') {\n                    const searchResults = await play.search(`${spotifyData.name} ${spotifyData.artists[0].name}`, { limit: 1 });\n                    if (searchResults.length > 0) {\n                        songInfo = await play.video_info(searchResults[0].url);\n                    }\n                }\n            } else if (play.so_validate(query)) {\n                songInfo = await play.soundcloud(query);\n            } else {\n                const searchResults = await play.search(query, { limit: 1 });\n                if (searchResults.length > 0) {\n                    songInfo = await play.video_info(searchResults[0].url);\n                }\n            }\n\n            if (!songInfo) {\n                return searchMsg.edit('‚ùå No results found! Try a different search.');\n            }\n\n            const song = {\n                title: songInfo.video_details?.title || 'Unknown',\n                url: songInfo.video_details?.url || query\n            };\n\n            let serverQueue = client.queues.get(message.guild.id);\n\n            if (!serverQueue) {\n                const connection = joinVoiceChannel({\n                    channelId: voiceChannel.id,\n                    guildId: message.guild.id,\n                    adapterCreator: message.guild.voiceAdapterCreator,\n                    selfDeaf: true\n                });\n\n                const player = createAudioPlayer();\n\n                player.on(AudioPlayerStatus.Idle, () => {\n                    const queue = client.queues.get(message.guild.id);\n                    if (queue) {\n                        queue.songs.shift();\n                        playNext(message.guild.id, client);\n                    }\n                });\n\n                player.on('error', error => {\n                    console.error('Player error:', error);\n                    const queue = client.queues.get(message.guild.id);\n                    if (queue) {\n                        queue.songs.shift();\n                        playNext(message.guild.id, client);\n                    }\n                });\n\n                connection.subscribe(player);\n\n                serverQueue = {\n                    textChannel: message.channel,\n                    voiceChannel: voiceChannel,\n                    connection: connection,\n                    player: player,\n                    songs: [song]\n                };\n\n                client.queues.set(message.guild.id, serverQueue);\n                await searchMsg.edit(`‚úÖ **${song.title}**\\nüéµ Playing best quality audio`);\n                playNext(message.guild.id, client);\n            } else {\n                serverQueue.songs.push(song);\n                await searchMsg.edit(`‚úÖ Added to queue: **${song.title}**`);\n            }\n\n        } catch (error) {\n            console.error('Play error:', error);\n            await searchMsg.edit(`‚ùå Error: ${error.message || 'Could not play!'}\\nTry a different song.`);\n        }\n    }\n};\n","size_bytes":5464},"settings/config.js":{"content":"module.exports = {\n    prefix: '!',\n    inactivityTimeout: 120000,\n    embedColor: '#0099ff'\n};\n","size_bytes":96}},"version":1}